/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ContractsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    getById(id: number): Promise<ContractDto | null> {
        let url_ = this.baseUrl + "/api/Contracts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<ContractDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContractDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractDto | null>(<any>null);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Contracts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    get(): Promise<ContractDto[] | null> {
        let url_ = this.baseUrl + "/api/Contracts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<ContractDto[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractDto[] | null>(<any>null);
    }

    put(value: ContractDto): Promise<ContractDto | null> {
        let url_ = this.baseUrl + "/api/Contracts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<ContractDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ContractDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractDto | null>(<any>null);
    }

    post(value: ContractDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Contracts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CustomersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    getByContractId(id: number | undefined, page: number | undefined, pageSize: number | undefined, globalFilter: string | null | undefined, contract: string): Promise<CustomerDto[] | null> {
        let url_ = this.baseUrl + "/api/Customers/{contract}?";
        if (contract === undefined || contract === null)
            throw new Error("The parameter 'contract' must be defined.");
        url_ = url_.replace("{contract}", encodeURIComponent("" + contract)); 
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (globalFilter !== undefined)
            url_ += "globalFilter=" + encodeURIComponent("" + globalFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByContractId(_response);
        });
    }

    protected processGetByContractId(response: Response): Promise<CustomerDto[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDto[] | null>(<any>null);
    }

    getByCustomerId(id: number): Promise<CustomerInsuranceCasesDto[] | null> {
        let url_ = this.baseUrl + "/api/Customers/{id}/cases";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByCustomerId(_response);
        });
    }

    protected processGetByCustomerId(response: Response): Promise<CustomerInsuranceCasesDto[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerInsuranceCasesDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerInsuranceCasesDto[] | null>(<any>null);
    }

    getShortDetails(id: number): Promise<CustomerShortDetailsDto | null> {
        let url_ = this.baseUrl + "/api/Customers/{id}/short";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetShortDetails(_response);
        });
    }

    protected processGetShortDetails(response: Response): Promise<CustomerShortDetailsDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerShortDetailsDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerShortDetailsDto | null>(<any>null);
    }

    getById(id: number): Promise<CustomerDto | null> {
        let url_ = this.baseUrl + "/api/Customers/{id}/full";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<CustomerDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDto | null>(<any>null);
    }

    getDepartmentsByContract(id: number | undefined, s: string | null | undefined): Promise<string[] | null> {
        let url_ = this.baseUrl + "/api/Customers/departments?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDepartmentsByContract(_response);
        });
    }

    protected processGetDepartmentsByContract(response: Response): Promise<string[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[] | null>(<any>null);
    }

    put(value: CustomerDto): Promise<CustomerDto | null> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<CustomerDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CustomerDto | null>(<any>null);
    }

    post(value: CustomerDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Customers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class IdentityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    getAll(): Promise<ApplicationUserDto[] | null> {
        let url_ = this.baseUrl + "/api/Identity/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ApplicationUserDto[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationUserDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUserDto[] | null>(<any>null);
    }

    create(dto: ApplicationUserDto): Promise<void> {
        let url_ = this.baseUrl + "/api/Identity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    delete(username: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Identity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(username);

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    update(dto: ApplicationUserDto): Promise<ApplicationUserDto | null> {
        let url_ = this.baseUrl + "/api/Identity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<ApplicationUserDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ApplicationUserDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationUserDto | null>(<any>null);
    }
}

export class InsuranceCasesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    getById(id: number): Promise<InsuranceCaseDto | null> {
        let url_ = this.baseUrl + "/api/InsuranceCases/{id}/full";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<InsuranceCaseDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InsuranceCaseDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InsuranceCaseDto | null>(<any>null);
    }

    post(value: MedicalInsuranceCaseDto): Promise<void> {
        let url_ = this.baseUrl + "/api/InsuranceCases/medical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    put(value: MedicalInsuranceCaseDto): Promise<MedicalInsuranceCaseDto | null> {
        let url_ = this.baseUrl + "/api/InsuranceCases/medical";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPut(_response);
        });
    }

    protected processPut(response: Response): Promise<MedicalInsuranceCaseDto | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MedicalInsuranceCaseDto.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : <any>null;
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MedicalInsuranceCaseDto | null>(<any>null);
    }
}

export class LookupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    getTherapy(): Promise<string[] | null> {
        let url_ = this.baseUrl + "/api/Lookup/therapy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTherapy(_response);
        });
    }

    protected processGetTherapy(response: Response): Promise<string[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[] | null>(<any>null);
    }

    getTreatments(): Promise<string[] | null> {
        let url_ = this.baseUrl + "/api/Lookup/treatment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTreatments(_response);
        });
    }

    protected processGetTreatments(response: Response): Promise<string[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[] | null>(<any>null);
    }

    getHospitals(id: number | null): Promise<HospitalDto[] | null> {
        let url_ = this.baseUrl + "/api/Lookup/{id}/hospital";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHospitals(_response);
        });
    }

    protected processGetHospitals(response: Response): Promise<HospitalDto[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(HospitalDto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HospitalDto[] | null>(<any>null);
    }

    getMkb10(s: string | null): Promise<Mkb10Dto[] | null> {
        let url_ = this.baseUrl + "/api/Lookup/{s}/mkb10";
        if (s === undefined || s === null)
            throw new Error("The parameter 's' must be defined.");
        url_ = url_.replace("{s}", encodeURIComponent("" + s)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMkb10(_response);
        });
    }

    protected processGetMkb10(response: Response): Promise<Mkb10Dto[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Mkb10Dto.fromJS(item));
            }
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Mkb10Dto[] | null>(<any>null);
    }
}

export class ContractDto implements IContractDto {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;
    beginDate?: Date;
    endDate?: Date;
    isActive?: boolean;

    constructor(data?: IContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.code = data["code"];
            this.description = data["description"];
            this.beginDate = data["beginDate"] ? new Date(data["beginDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): ContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["beginDate"] = this.beginDate ? this.beginDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IContractDto {
    id?: number;
    name?: string | undefined;
    code?: string | undefined;
    description?: string | undefined;
    beginDate?: Date;
    endDate?: Date;
    isActive?: boolean;
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export class ProblemDetails implements IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.status = data["status"];
            this.detail = data["detail"];
            this.instance = data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

/** A machine-readable format for specifying errors in HTTP API responses based on https://tools.ietf.org/html/rfc7807. */
export interface IProblemDetails {
    /** A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
dereferenced, it provide human-readable documentation for the problem type
(e.g., using HTML [W3C.REC-html5-20141028]).  When this member is not present, its value is assumed to be
"about:blank". */
    type?: string | undefined;
    /** A short, human-readable summary of the problem type.It SHOULD NOT change from occurrence to occurrence
of the problem, except for purposes of localization(e.g., using proactive content negotiation;
see[RFC7231], Section 3.4). */
    title?: string | undefined;
    /** The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem. */
    status?: number | undefined;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail?: string | undefined;
    /** A URI reference that identifies the specific occurrence of the problem.It may or may not yield further information if dereferenced. */
    instance?: string | undefined;
}

export class CustomerDto implements ICustomerDto {
    id?: number;
    contractId?: number;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    tin?: string | undefined;
    department?: string | undefined;
    personnelNumber?: string | undefined;
    disabilityGroup?: number | undefined;
    mobilePhone?: string | undefined;
    position?: string | undefined;
    additionalInfo?: string | undefined;
    cardNumber?: string | undefined;
    address?: string | undefined;
    sex?: boolean | undefined;
    passport?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contractId = data["contractId"];
            this.name = data["name"];
            this.dateOfBirth = data["dateOfBirth"] ? new Date(data["dateOfBirth"].toString()) : <any>undefined;
            this.tin = data["tin"];
            this.department = data["department"];
            this.personnelNumber = data["personnelNumber"];
            this.disabilityGroup = data["disabilityGroup"];
            this.mobilePhone = data["mobilePhone"];
            this.position = data["position"];
            this.additionalInfo = data["additionalInfo"];
            this.cardNumber = data["cardNumber"];
            this.address = data["address"];
            this.sex = data["sex"];
            this.passport = data["passport"];
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contractId"] = this.contractId;
        data["name"] = this.name;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["tin"] = this.tin;
        data["department"] = this.department;
        data["personnelNumber"] = this.personnelNumber;
        data["disabilityGroup"] = this.disabilityGroup;
        data["mobilePhone"] = this.mobilePhone;
        data["position"] = this.position;
        data["additionalInfo"] = this.additionalInfo;
        data["cardNumber"] = this.cardNumber;
        data["address"] = this.address;
        data["sex"] = this.sex;
        data["passport"] = this.passport;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICustomerDto {
    id?: number;
    contractId?: number;
    name?: string | undefined;
    dateOfBirth?: Date | undefined;
    tin?: string | undefined;
    department?: string | undefined;
    personnelNumber?: string | undefined;
    disabilityGroup?: number | undefined;
    mobilePhone?: string | undefined;
    position?: string | undefined;
    additionalInfo?: string | undefined;
    cardNumber?: string | undefined;
    address?: string | undefined;
    sex?: boolean | undefined;
    passport?: string | undefined;
    startDate?: Date;
    endDate?: Date | undefined;
}

export class CustomerInsuranceCasesDto implements ICustomerInsuranceCasesDto {
    id?: number;
    name?: string | undefined;
    contractId?: number;
    insuranceCases?: InsuranceCaseItemDto[] | undefined;

    constructor(data?: ICustomerInsuranceCasesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.contractId = data["contractId"];
            if (data["insuranceCases"] && data["insuranceCases"].constructor === Array) {
                this.insuranceCases = [] as any;
                for (let item of data["insuranceCases"])
                    this.insuranceCases!.push(InsuranceCaseItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerInsuranceCasesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInsuranceCasesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["contractId"] = this.contractId;
        if (this.insuranceCases && this.insuranceCases.constructor === Array) {
            data["insuranceCases"] = [];
            for (let item of this.insuranceCases)
                data["insuranceCases"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerInsuranceCasesDto {
    id?: number;
    name?: string | undefined;
    contractId?: number;
    insuranceCases?: InsuranceCaseItemDto[] | undefined;
}

export class InsuranceCaseItemDto implements IInsuranceCaseItemDto {
    id?: number;
    mkb10Code?: string | undefined;
    treatment?: Treatment | undefined;
    hospitalName?: string | undefined;
    beginDate?: Date | undefined;
    endDate?: Date | undefined;
    totalAmount?: number | undefined;

    constructor(data?: IInsuranceCaseItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.mkb10Code = data["mkb10Code"];
            this.treatment = data["treatment"];
            this.hospitalName = data["hospitalName"];
            this.beginDate = data["beginDate"] ? new Date(data["beginDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): InsuranceCaseItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new InsuranceCaseItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mkb10Code"] = this.mkb10Code;
        data["treatment"] = this.treatment;
        data["hospitalName"] = this.hospitalName;
        data["beginDate"] = this.beginDate ? this.beginDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }
}

export interface IInsuranceCaseItemDto {
    id?: number;
    mkb10Code?: string | undefined;
    treatment?: Treatment | undefined;
    hospitalName?: string | undefined;
    beginDate?: Date | undefined;
    endDate?: Date | undefined;
    totalAmount?: number | undefined;
}

export enum Treatment {
    Polyclinic = "Поликлиника", 
    Hospital = "Стационар", 
    EmergencyRoom = "Травмпункт", 
    DayHospital = "Дневной стационар", 
    Pregnancy = "Беременность и Роды", 
    AdditionalOptions = "Дополнительные опции", 
    CriticalDiseases = "Критические заболевания", 
}

export class CustomerShortDetailsDto implements ICustomerShortDetailsDto {
    id?: number;
    department?: string | undefined;
    personnelNumber?: string | undefined;
    disabilityGroup?: number;
    mobilePhone?: string | undefined;
    position?: string | undefined;

    constructor(data?: ICustomerShortDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.department = data["department"];
            this.personnelNumber = data["personnelNumber"];
            this.disabilityGroup = data["disabilityGroup"];
            this.mobilePhone = data["mobilePhone"];
            this.position = data["position"];
        }
    }

    static fromJS(data: any): CustomerShortDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerShortDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["department"] = this.department;
        data["personnelNumber"] = this.personnelNumber;
        data["disabilityGroup"] = this.disabilityGroup;
        data["mobilePhone"] = this.mobilePhone;
        data["position"] = this.position;
        return data; 
    }
}

export interface ICustomerShortDetailsDto {
    id?: number;
    department?: string | undefined;
    personnelNumber?: string | undefined;
    disabilityGroup?: number;
    mobilePhone?: string | undefined;
    position?: string | undefined;
}

export class ApplicationUserDto implements IApplicationUserDto {
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    isAdmin?: boolean;
    isUser?: boolean;

    constructor(data?: IApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.email = data["email"];
            this.password = data["password"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.isAdmin = data["isAdmin"];
            this.isUser = data["isUser"];
        }
    }

    static fromJS(data: any): ApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["isAdmin"] = this.isAdmin;
        data["isUser"] = this.isUser;
        return data; 
    }
}

export interface IApplicationUserDto {
    email?: string | undefined;
    password?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    isAdmin?: boolean;
    isUser?: boolean;
}

export abstract class InsuranceCaseDto implements IInsuranceCaseDto {
    id?: number;
    customerId?: number;
    customerName?: string | undefined;
    caseType?: number;
    mkb10?: Mkb10Dto | undefined;
    treatment?: Treatment | undefined;
    therapy?: Therapy | undefined;
    hospitalId?: number | undefined;
    hospitalDepartmentId?: number | undefined;
    beginDate?: Date | undefined;
    endDate?: Date | undefined;

    constructor(data?: IInsuranceCaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerId = data["customerId"];
            this.customerName = data["customerName"];
            this.caseType = data["caseType"];
            this.mkb10 = data["mkb10"] ? Mkb10Dto.fromJS(data["mkb10"]) : <any>undefined;
            this.treatment = data["treatment"];
            this.therapy = data["therapy"];
            this.hospitalId = data["hospitalId"];
            this.hospitalDepartmentId = data["hospitalDepartmentId"];
            this.beginDate = data["beginDate"] ? new Date(data["beginDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InsuranceCaseDto {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'InsuranceCaseDto' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["caseType"] = this.caseType;
        data["mkb10"] = this.mkb10 ? this.mkb10.toJSON() : <any>undefined;
        data["treatment"] = this.treatment;
        data["therapy"] = this.therapy;
        data["hospitalId"] = this.hospitalId;
        data["hospitalDepartmentId"] = this.hospitalDepartmentId;
        data["beginDate"] = this.beginDate ? this.beginDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IInsuranceCaseDto {
    id?: number;
    customerId?: number;
    customerName?: string | undefined;
    caseType?: number;
    mkb10?: Mkb10Dto | undefined;
    treatment?: Treatment | undefined;
    therapy?: Therapy | undefined;
    hospitalId?: number | undefined;
    hospitalDepartmentId?: number | undefined;
    beginDate?: Date | undefined;
    endDate?: Date | undefined;
}

export class Mkb10Dto implements IMkb10Dto {
    id?: number;
    parentId?: number | undefined;
    code?: string | undefined;

    constructor(data?: IMkb10Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): Mkb10Dto {
        data = typeof data === 'object' ? data : {};
        let result = new Mkb10Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        return data; 
    }
}

export interface IMkb10Dto {
    id?: number;
    parentId?: number | undefined;
    code?: string | undefined;
}

export enum Therapy {
    Surgical = "Оперативное", 
    Conservative = "Консервативное", 
}

export class MedicalInsuranceCaseDto extends InsuranceCaseDto implements IMedicalInsuranceCaseDto {
    reportDate?: Date | undefined;
    documentDate?: Date | undefined;
    diagnosisCosts?: number | undefined;
    foodCosts?: number | undefined;
    treatmentСosts?: number | undefined;
    orders?: OrderDto[] | undefined;

    constructor(data?: IMedicalInsuranceCaseDto) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.reportDate = data["reportDate"] ? new Date(data["reportDate"].toString()) : <any>undefined;
            this.documentDate = data["documentDate"] ? new Date(data["documentDate"].toString()) : <any>undefined;
            this.diagnosisCosts = data["diagnosisCosts"];
            this.foodCosts = data["foodCosts"];
            this.treatmentСosts = data["treatmentСosts"];
            if (data["orders"] && data["orders"].constructor === Array) {
                this.orders = [] as any;
                for (let item of data["orders"])
                    this.orders!.push(OrderDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MedicalInsuranceCaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalInsuranceCaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportDate"] = this.reportDate ? this.reportDate.toISOString() : <any>undefined;
        data["documentDate"] = this.documentDate ? this.documentDate.toISOString() : <any>undefined;
        data["diagnosisCosts"] = this.diagnosisCosts;
        data["foodCosts"] = this.foodCosts;
        data["treatmentСosts"] = this.treatmentСosts;
        if (this.orders && this.orders.constructor === Array) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IMedicalInsuranceCaseDto extends IInsuranceCaseDto {
    reportDate?: Date | undefined;
    documentDate?: Date | undefined;
    diagnosisCosts?: number | undefined;
    foodCosts?: number | undefined;
    treatmentСosts?: number | undefined;
    orders?: OrderDto[] | undefined;
}

export class OrderDto implements IOrderDto {
    id?: number;
    recipeDate?: Date | undefined;
    orderDate?: Date | undefined;
    recipeNumber?: string | undefined;
    orderNumber?: string | undefined;
    pharmacy?: string | undefined;
    amount?: number;

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.recipeDate = data["recipeDate"] ? new Date(data["recipeDate"].toString()) : <any>undefined;
            this.orderDate = data["orderDate"] ? new Date(data["orderDate"].toString()) : <any>undefined;
            this.recipeNumber = data["recipeNumber"];
            this.orderNumber = data["orderNumber"];
            this.pharmacy = data["pharmacy"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["recipeDate"] = this.recipeDate ? this.recipeDate.toISOString() : <any>undefined;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : <any>undefined;
        data["recipeNumber"] = this.recipeNumber;
        data["orderNumber"] = this.orderNumber;
        data["pharmacy"] = this.pharmacy;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IOrderDto {
    id?: number;
    recipeDate?: Date | undefined;
    orderDate?: Date | undefined;
    recipeNumber?: string | undefined;
    orderNumber?: string | undefined;
    pharmacy?: string | undefined;
    amount?: number;
}

export class HospitalDto implements IHospitalDto {
    id?: number;
    parentId?: number | undefined;
    name?: string | undefined;

    constructor(data?: IHospitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): HospitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["name"] = this.name;
        return data; 
    }
}

export interface IHospitalDto {
    id?: number;
    parentId?: number | undefined;
    name?: string | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}