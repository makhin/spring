/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');


export abstract class ControllerBase implements IControllerBase {
    httpContext?: HttpContext | undefined;
    request?: HttpRequest | undefined;
    response?: HttpResponse | undefined;
    routeData?: RouteData | undefined;
    modelState?: ModelStateDictionary | undefined;
    controllerContext?: ControllerContext | undefined;
    metadataProvider?: IModelMetadataProvider | undefined;
    modelBinderFactory?: IModelBinderFactory | undefined;
    url?: IUrlHelper | undefined;
    objectValidator?: IObjectModelValidator | undefined;
    user?: ClaimsPrincipal | undefined;

    constructor(data?: IControllerBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.httpContext = data["HttpContext"] ? HttpContext.fromJS(data["HttpContext"]) : <any>undefined;
            this.request = data["Request"] ? HttpRequest.fromJS(data["Request"]) : <any>undefined;
            this.response = data["Response"] ? HttpResponse.fromJS(data["Response"]) : <any>undefined;
            this.routeData = data["RouteData"] ? RouteData.fromJS(data["RouteData"]) : <any>undefined;
            this.modelState = data["ModelState"] ? ModelStateDictionary.fromJS(data["ModelState"]) : <any>undefined;
            this.controllerContext = data["ControllerContext"] ? ControllerContext.fromJS(data["ControllerContext"]) : <any>undefined;
            this.metadataProvider = data["MetadataProvider"] ? IModelMetadataProvider.fromJS(data["MetadataProvider"]) : <any>undefined;
            this.modelBinderFactory = data["ModelBinderFactory"] ? IModelBinderFactory.fromJS(data["ModelBinderFactory"]) : <any>undefined;
            this.url = data["Url"] ? IUrlHelper.fromJS(data["Url"]) : <any>undefined;
            this.objectValidator = data["ObjectValidator"] ? IObjectModelValidator.fromJS(data["ObjectValidator"]) : <any>undefined;
            this.user = data["User"] ? ClaimsPrincipal.fromJS(data["User"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ControllerBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ControllerBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["HttpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["Request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["Response"] = this.response ? this.response.toJSON() : <any>undefined;
        data["RouteData"] = this.routeData ? this.routeData.toJSON() : <any>undefined;
        data["ModelState"] = this.modelState ? this.modelState.toJSON() : <any>undefined;
        data["ControllerContext"] = this.controllerContext ? this.controllerContext.toJSON() : <any>undefined;
        data["MetadataProvider"] = this.metadataProvider ? this.metadataProvider.toJSON() : <any>undefined;
        data["ModelBinderFactory"] = this.modelBinderFactory ? this.modelBinderFactory.toJSON() : <any>undefined;
        data["Url"] = this.url ? this.url.toJSON() : <any>undefined;
        data["ObjectValidator"] = this.objectValidator ? this.objectValidator.toJSON() : <any>undefined;
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IControllerBase {
    httpContext?: HttpContext | undefined;
    request?: HttpRequest | undefined;
    response?: HttpResponse | undefined;
    routeData?: RouteData | undefined;
    modelState?: ModelStateDictionary | undefined;
    controllerContext?: ControllerContext | undefined;
    metadataProvider?: IModelMetadataProvider | undefined;
    modelBinderFactory?: IModelBinderFactory | undefined;
    url?: IUrlHelper | undefined;
    objectValidator?: IObjectModelValidator | undefined;
    user?: ClaimsPrincipal | undefined;
}

export abstract class Controller extends ControllerBase implements IController {
    viewData?: ViewDataDictionary | undefined;
    tempData?: ITempDataDictionary | undefined;
    viewBag?: any | undefined;

    constructor(data?: IController) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.viewData = data["ViewData"] ? ViewDataDictionary.fromJS(data["ViewData"]) : <any>undefined;
            this.tempData = data["TempData"] ? ITempDataDictionary.fromJS(data["TempData"]) : <any>undefined;
            this.viewBag = data["ViewBag"];
        }
    }

    static fromJS(data: any): Controller {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Controller' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ViewData"] = this.viewData ? this.viewData.toJSON() : <any>undefined;
        data["TempData"] = this.tempData ? this.tempData.toJSON() : <any>undefined;
        data["ViewBag"] = this.viewBag;
        super.toJSON(data);
        return data; 
    }
}

export interface IController extends IControllerBase {
    viewData?: ViewDataDictionary | undefined;
    tempData?: ITempDataDictionary | undefined;
    viewBag?: any | undefined;
}

export class ContractsController extends Controller implements IContractsController {

    constructor(data?: IContractsController) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): ContractsController {
        data = typeof data === 'object' ? data : {};
        let result = new ContractsController();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IContractsController extends IController {
}

export class ViewDataDictionary implements IViewDataDictionary {
    model?: any | undefined;
    modelState?: ModelStateDictionary | undefined;
    modelMetadata?: ModelMetadata | undefined;
    modelExplorer?: ModelExplorer | undefined;
    templateInfo?: TemplateInfo | undefined;
    item?: any | undefined;
    count?: number;
    isReadOnly?: boolean;
    keys?: string[] | undefined;
    values?: any[] | undefined;

    constructor(data?: IViewDataDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.model = data["Model"];
            this.modelState = data["ModelState"] ? ModelStateDictionary.fromJS(data["ModelState"]) : <any>undefined;
            this.modelMetadata = data["ModelMetadata"] ? ModelMetadata.fromJS(data["ModelMetadata"]) : <any>undefined;
            this.modelExplorer = data["ModelExplorer"] ? ModelExplorer.fromJS(data["ModelExplorer"]) : <any>undefined;
            this.templateInfo = data["TemplateInfo"] ? TemplateInfo.fromJS(data["TemplateInfo"]) : <any>undefined;
            this.item = data["Item"];
            this.count = data["Count"];
            this.isReadOnly = data["IsReadOnly"];
            if (data["Keys"] && data["Keys"].constructor === Array) {
                this.keys = [] as any;
                for (let item of data["Keys"])
                    this.keys!.push(item);
            }
            if (data["Values"] && data["Values"].constructor === Array) {
                this.values = [] as any;
                for (let item of data["Values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): ViewDataDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new ViewDataDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Model"] = this.model;
        data["ModelState"] = this.modelState ? this.modelState.toJSON() : <any>undefined;
        data["ModelMetadata"] = this.modelMetadata ? this.modelMetadata.toJSON() : <any>undefined;
        data["ModelExplorer"] = this.modelExplorer ? this.modelExplorer.toJSON() : <any>undefined;
        data["TemplateInfo"] = this.templateInfo ? this.templateInfo.toJSON() : <any>undefined;
        data["Item"] = this.item;
        data["Count"] = this.count;
        data["IsReadOnly"] = this.isReadOnly;
        if (this.keys && this.keys.constructor === Array) {
            data["Keys"] = [];
            for (let item of this.keys)
                data["Keys"].push(item);
        }
        if (this.values && this.values.constructor === Array) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item);
        }
        return data; 
    }
}

export interface IViewDataDictionary {
    model?: any | undefined;
    modelState?: ModelStateDictionary | undefined;
    modelMetadata?: ModelMetadata | undefined;
    modelExplorer?: ModelExplorer | undefined;
    templateInfo?: TemplateInfo | undefined;
    item?: any | undefined;
    count?: number;
    isReadOnly?: boolean;
    keys?: string[] | undefined;
    values?: any[] | undefined;
}

export class ModelStateDictionary implements IModelStateDictionary {
    root?: ModelStateEntry | undefined;
    maxAllowedErrors?: number;
    hasReachedMaxErrors?: boolean;
    errorCount?: number;
    count?: number;
    keys?: string[];
    values?: ModelStateEntry[];
    isValid?: boolean;
    validationState?: ModelValidationState;
    item?: ModelStateEntry | undefined;

    constructor(data?: IModelStateDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.root = data["Root"] ? ModelStateEntry.fromJS(data["Root"]) : <any>undefined;
            this.maxAllowedErrors = data["MaxAllowedErrors"];
            this.hasReachedMaxErrors = data["HasReachedMaxErrors"];
            this.errorCount = data["ErrorCount"];
            this.count = data["Count"];
            if (data["Keys"] && data["Keys"].constructor === Array) {
                this.keys = [] as any;
                for (let item of data["Keys"])
                    this.keys!.push(item);
            }
            if (data["Values"] && data["Values"].constructor === Array) {
                this.values = [] as any;
                for (let item of data["Values"])
                    this.values!.push(ModelStateEntry.fromJS(item));
            }
            this.isValid = data["IsValid"];
            this.validationState = data["ValidationState"];
            this.item = data["Item"] ? ModelStateEntry.fromJS(data["Item"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ModelStateDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new ModelStateDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Root"] = this.root ? this.root.toJSON() : <any>undefined;
        data["MaxAllowedErrors"] = this.maxAllowedErrors;
        data["HasReachedMaxErrors"] = this.hasReachedMaxErrors;
        data["ErrorCount"] = this.errorCount;
        data["Count"] = this.count;
        if (this.keys && this.keys.constructor === Array) {
            data["Keys"] = [];
            for (let item of this.keys)
                data["Keys"].push(item);
        }
        if (this.values && this.values.constructor === Array) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item.toJSON());
        }
        data["IsValid"] = this.isValid;
        data["ValidationState"] = this.validationState;
        data["Item"] = this.item ? this.item.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IModelStateDictionary {
    root?: ModelStateEntry | undefined;
    maxAllowedErrors?: number;
    hasReachedMaxErrors?: boolean;
    errorCount?: number;
    count?: number;
    keys?: string[];
    values?: ModelStateEntry[];
    isValid?: boolean;
    validationState?: ModelValidationState;
    item?: ModelStateEntry | undefined;
}

export abstract class ModelStateEntry implements IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    errors?: ModelError[] | undefined;
    validationState?: ModelValidationState;

    constructor(data?: IModelStateEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rawValue = data["RawValue"];
            this.attemptedValue = data["AttemptedValue"];
            if (data["Errors"] && data["Errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["Errors"])
                    this.errors!.push(ModelError.fromJS(item));
            }
            this.validationState = data["ValidationState"];
        }
    }

    static fromJS(data: any): ModelStateEntry {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ModelStateEntry' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["RawValue"] = this.rawValue;
        data["AttemptedValue"] = this.attemptedValue;
        if (this.errors && this.errors.constructor === Array) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item.toJSON());
        }
        data["ValidationState"] = this.validationState;
        return data; 
    }
}

export interface IModelStateEntry {
    rawValue?: any | undefined;
    attemptedValue?: string | undefined;
    errors?: ModelError[] | undefined;
    validationState?: ModelValidationState;
}

export class ModelError implements IModelError {
    exception?: Exception | undefined;
    errorMessage?: string | undefined;

    constructor(data?: IModelError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exception = data["Exception"] ? Exception.fromJS(data["Exception"]) : <any>undefined;
            this.errorMessage = data["ErrorMessage"];
        }
    }

    static fromJS(data: any): ModelError {
        data = typeof data === 'object' ? data : {};
        let result = new ModelError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Exception"] = this.exception ? this.exception.toJSON() : <any>undefined;
        data["ErrorMessage"] = this.errorMessage;
        return data; 
    }
}

export interface IModelError {
    exception?: Exception | undefined;
    errorMessage?: string | undefined;
}

export class Exception implements IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;

    constructor(data?: IException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["Message"];
            this.innerException = data["InnerException"] ? Exception.fromJS(data["InnerException"]) : <any>undefined;
            this.stackTrace = data["StackTrace"];
            this.source = data["Source"];
        }
    }

    static fromJS(data: any): Exception {
        data = typeof data === 'object' ? data : {};
        let result = new Exception();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Message"] = this.message;
        data["InnerException"] = this.innerException ? this.innerException.toJSON() : <any>undefined;
        data["StackTrace"] = this.stackTrace;
        data["Source"] = this.source;
        return data; 
    }
}

export interface IException {
    message?: string | undefined;
    innerException?: Exception | undefined;
    stackTrace?: string | undefined;
    source?: string | undefined;
}

export enum ModelValidationState {
    Unvalidated = 0, 
    Invalid = 1, 
    Valid = 2, 
    Skipped = 3, 
}

export abstract class ModelMetadata implements IModelMetadata {
    containerType?: string | undefined;
    containerMetadata?: ModelMetadata | undefined;
    metadataKind?: ModelMetadataKind;
    modelType?: string | undefined;
    name?: string | undefined;
    parameterName?: string | undefined;
    propertyName?: string | undefined;
    propertyValidationFilter?: IPropertyValidationFilter | undefined;
    hasValidators?: boolean | undefined;
    elementType?: string | undefined;
    isComplexType?: boolean;
    isNullableValueType?: boolean;
    isCollectionType?: boolean;
    isEnumerableType?: boolean;
    isReferenceOrNullableType?: boolean;
    underlyingOrModelType?: string | undefined;

    constructor(data?: IModelMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.containerType = data["ContainerType"];
            this.containerMetadata = data["ContainerMetadata"] ? ModelMetadata.fromJS(data["ContainerMetadata"]) : <any>undefined;
            this.metadataKind = data["MetadataKind"];
            this.modelType = data["ModelType"];
            this.name = data["Name"];
            this.parameterName = data["ParameterName"];
            this.propertyName = data["PropertyName"];
            this.propertyValidationFilter = data["PropertyValidationFilter"] ? IPropertyValidationFilter.fromJS(data["PropertyValidationFilter"]) : <any>undefined;
            this.hasValidators = data["HasValidators"];
            this.elementType = data["ElementType"];
            this.isComplexType = data["IsComplexType"];
            this.isNullableValueType = data["IsNullableValueType"];
            this.isCollectionType = data["IsCollectionType"];
            this.isEnumerableType = data["IsEnumerableType"];
            this.isReferenceOrNullableType = data["IsReferenceOrNullableType"];
            this.underlyingOrModelType = data["UnderlyingOrModelType"];
        }
    }

    static fromJS(data: any): ModelMetadata {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ModelMetadata' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ContainerType"] = this.containerType;
        data["ContainerMetadata"] = this.containerMetadata ? this.containerMetadata.toJSON() : <any>undefined;
        data["MetadataKind"] = this.metadataKind;
        data["ModelType"] = this.modelType;
        data["Name"] = this.name;
        data["ParameterName"] = this.parameterName;
        data["PropertyName"] = this.propertyName;
        data["PropertyValidationFilter"] = this.propertyValidationFilter ? this.propertyValidationFilter.toJSON() : <any>undefined;
        data["HasValidators"] = this.hasValidators;
        data["ElementType"] = this.elementType;
        data["IsComplexType"] = this.isComplexType;
        data["IsNullableValueType"] = this.isNullableValueType;
        data["IsCollectionType"] = this.isCollectionType;
        data["IsEnumerableType"] = this.isEnumerableType;
        data["IsReferenceOrNullableType"] = this.isReferenceOrNullableType;
        data["UnderlyingOrModelType"] = this.underlyingOrModelType;
        return data; 
    }
}

export interface IModelMetadata {
    containerType?: string | undefined;
    containerMetadata?: ModelMetadata | undefined;
    metadataKind?: ModelMetadataKind;
    modelType?: string | undefined;
    name?: string | undefined;
    parameterName?: string | undefined;
    propertyName?: string | undefined;
    propertyValidationFilter?: IPropertyValidationFilter | undefined;
    hasValidators?: boolean | undefined;
    elementType?: string | undefined;
    isComplexType?: boolean;
    isNullableValueType?: boolean;
    isCollectionType?: boolean;
    isEnumerableType?: boolean;
    isReferenceOrNullableType?: boolean;
    underlyingOrModelType?: string | undefined;
}

export enum ModelMetadataKind {
    Type = 0, 
    Property = 1, 
    Parameter = 2, 
}

export abstract class IPropertyValidationFilter implements IIPropertyValidationFilter {

    constructor(data?: IIPropertyValidationFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IPropertyValidationFilter {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IPropertyValidationFilter' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIPropertyValidationFilter {
}

export class ModelExplorer implements IModelExplorer {
    container?: ModelExplorer | undefined;
    metadata?: ModelMetadata | undefined;
    model?: any | undefined;
    modelType?: string | undefined;
    properties?: ModelExplorer[] | undefined;

    constructor(data?: IModelExplorer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.container = data["Container"] ? ModelExplorer.fromJS(data["Container"]) : <any>undefined;
            this.metadata = data["Metadata"] ? ModelMetadata.fromJS(data["Metadata"]) : <any>undefined;
            this.model = data["Model"];
            this.modelType = data["ModelType"];
            if (data["Properties"] && data["Properties"].constructor === Array) {
                this.properties = [] as any;
                for (let item of data["Properties"])
                    this.properties!.push(ModelExplorer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ModelExplorer {
        data = typeof data === 'object' ? data : {};
        let result = new ModelExplorer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Container"] = this.container ? this.container.toJSON() : <any>undefined;
        data["Metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["Model"] = this.model;
        data["ModelType"] = this.modelType;
        if (this.properties && this.properties.constructor === Array) {
            data["Properties"] = [];
            for (let item of this.properties)
                data["Properties"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IModelExplorer {
    container?: ModelExplorer | undefined;
    metadata?: ModelMetadata | undefined;
    model?: any | undefined;
    modelType?: string | undefined;
    properties?: ModelExplorer[] | undefined;
}

export class TemplateInfo implements ITemplateInfo {
    formattedModelValue?: any | undefined;
    htmlFieldPrefix?: string | undefined;
    templateDepth?: number;

    constructor(data?: ITemplateInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.formattedModelValue = data["FormattedModelValue"];
            this.htmlFieldPrefix = data["HtmlFieldPrefix"];
            this.templateDepth = data["TemplateDepth"];
        }
    }

    static fromJS(data: any): TemplateInfo {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["FormattedModelValue"] = this.formattedModelValue;
        data["HtmlFieldPrefix"] = this.htmlFieldPrefix;
        data["TemplateDepth"] = this.templateDepth;
        return data; 
    }
}

export interface ITemplateInfo {
    formattedModelValue?: any | undefined;
    htmlFieldPrefix?: string | undefined;
    templateDepth?: number;
}

export abstract class ITempDataDictionary implements IITempDataDictionary {

    constructor(data?: IITempDataDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): ITempDataDictionary {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ITempDataDictionary' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IITempDataDictionary {
}

export abstract class HttpContext implements IHttpContext {

    constructor(data?: IHttpContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): HttpContext {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpContext' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IHttpContext {
}

export abstract class HttpRequest implements IHttpRequest {

    constructor(data?: IHttpRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): HttpRequest {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpRequest' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IHttpRequest {
}

export abstract class HttpResponse implements IHttpResponse {

    constructor(data?: IHttpResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): HttpResponse {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'HttpResponse' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IHttpResponse {
}

export class RouteData implements IRouteData {
    dataTokens?: RouteValueDictionary | undefined;
    routers?: IRouter[] | undefined;
    values?: RouteValueDictionary | undefined;

    constructor(data?: IRouteData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dataTokens = data["DataTokens"] ? RouteValueDictionary.fromJS(data["DataTokens"]) : <any>undefined;
            if (data["Routers"] && data["Routers"].constructor === Array) {
                this.routers = [] as any;
                for (let item of data["Routers"])
                    this.routers!.push(IRouter.fromJS(item));
            }
            this.values = data["Values"] ? RouteValueDictionary.fromJS(data["Values"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RouteData {
        data = typeof data === 'object' ? data : {};
        let result = new RouteData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DataTokens"] = this.dataTokens ? this.dataTokens.toJSON() : <any>undefined;
        if (this.routers && this.routers.constructor === Array) {
            data["Routers"] = [];
            for (let item of this.routers)
                data["Routers"].push(item.toJSON());
        }
        data["Values"] = this.values ? this.values.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRouteData {
    dataTokens?: RouteValueDictionary | undefined;
    routers?: IRouter[] | undefined;
    values?: RouteValueDictionary | undefined;
}

export class RouteValueDictionary implements IRouteValueDictionary {
    item?: any | undefined;
    comparer?: IEqualityComparerOfString | undefined;
    count?: number;
    keys?: string[] | undefined;
    values?: any[] | undefined;

    constructor(data?: IRouteValueDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.item = data["Item"];
            this.comparer = data["Comparer"] ? IEqualityComparerOfString.fromJS(data["Comparer"]) : <any>undefined;
            this.count = data["Count"];
            if (data["Keys"] && data["Keys"].constructor === Array) {
                this.keys = [] as any;
                for (let item of data["Keys"])
                    this.keys!.push(item);
            }
            if (data["Values"] && data["Values"].constructor === Array) {
                this.values = [] as any;
                for (let item of data["Values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): RouteValueDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new RouteValueDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Item"] = this.item;
        data["Comparer"] = this.comparer ? this.comparer.toJSON() : <any>undefined;
        data["Count"] = this.count;
        if (this.keys && this.keys.constructor === Array) {
            data["Keys"] = [];
            for (let item of this.keys)
                data["Keys"].push(item);
        }
        if (this.values && this.values.constructor === Array) {
            data["Values"] = [];
            for (let item of this.values)
                data["Values"].push(item);
        }
        return data; 
    }
}

export interface IRouteValueDictionary {
    item?: any | undefined;
    comparer?: IEqualityComparerOfString | undefined;
    count?: number;
    keys?: string[] | undefined;
    values?: any[] | undefined;
}

export abstract class IEqualityComparerOfString implements IIEqualityComparerOfString {

    constructor(data?: IIEqualityComparerOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IEqualityComparerOfString {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IEqualityComparerOfString' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIEqualityComparerOfString {
}

export abstract class IRouter implements IIRouter {

    constructor(data?: IIRouter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IRouter {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IRouter' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIRouter {
}

export class ActionContext implements IActionContext {
    actionDescriptor?: ActionDescriptor | undefined;
    httpContext?: HttpContext | undefined;
    modelState?: ModelStateDictionary | undefined;
    routeData?: RouteData | undefined;

    constructor(data?: IActionContext) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionDescriptor = data["ActionDescriptor"] ? ActionDescriptor.fromJS(data["ActionDescriptor"]) : <any>undefined;
            this.httpContext = data["HttpContext"] ? HttpContext.fromJS(data["HttpContext"]) : <any>undefined;
            this.modelState = data["ModelState"] ? ModelStateDictionary.fromJS(data["ModelState"]) : <any>undefined;
            this.routeData = data["RouteData"] ? RouteData.fromJS(data["RouteData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionContext {
        data = typeof data === 'object' ? data : {};
        let result = new ActionContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ActionDescriptor"] = this.actionDescriptor ? this.actionDescriptor.toJSON() : <any>undefined;
        data["HttpContext"] = this.httpContext ? this.httpContext.toJSON() : <any>undefined;
        data["ModelState"] = this.modelState ? this.modelState.toJSON() : <any>undefined;
        data["RouteData"] = this.routeData ? this.routeData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionContext {
    actionDescriptor?: ActionDescriptor | undefined;
    httpContext?: HttpContext | undefined;
    modelState?: ModelStateDictionary | undefined;
    routeData?: RouteData | undefined;
}

export class ControllerContext extends ActionContext implements IControllerContext {
    actionDescriptor?: ControllerActionDescriptor | undefined;
    valueProviderFactories?: IValueProviderFactory[] | undefined;

    constructor(data?: IControllerContext) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.actionDescriptor = data["ActionDescriptor"] ? ControllerActionDescriptor.fromJS(data["ActionDescriptor"]) : <any>undefined;
            if (data["ValueProviderFactories"] && data["ValueProviderFactories"].constructor === Array) {
                this.valueProviderFactories = [] as any;
                for (let item of data["ValueProviderFactories"])
                    this.valueProviderFactories!.push(IValueProviderFactory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ControllerContext {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerContext();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ActionDescriptor"] = this.actionDescriptor ? this.actionDescriptor.toJSON() : <any>undefined;
        if (this.valueProviderFactories && this.valueProviderFactories.constructor === Array) {
            data["ValueProviderFactories"] = [];
            for (let item of this.valueProviderFactories)
                data["ValueProviderFactories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IControllerContext extends IActionContext {
    actionDescriptor?: ControllerActionDescriptor | undefined;
    valueProviderFactories?: IValueProviderFactory[] | undefined;
}

export class ActionDescriptor implements IActionDescriptor {
    id?: string | undefined;
    routeValues?: { [key: string] : string; } | undefined;
    attributeRouteInfo?: AttributeRouteInfo | undefined;
    actionConstraints?: IActionConstraintMetadata[] | undefined;
    endpointMetadata?: any[] | undefined;
    parameters?: ParameterDescriptor[] | undefined;
    boundProperties?: ParameterDescriptor[] | undefined;
    filterDescriptors?: FilterDescriptor[] | undefined;
    displayName?: string | undefined;
    properties?: { [key: string] : any; } | undefined;

    constructor(data?: IActionDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["Id"];
            if (data["RouteValues"]) {
                this.routeValues = {} as any;
                for (let key in data["RouteValues"]) {
                    if (data["RouteValues"].hasOwnProperty(key))
                        this.routeValues![key] = data["RouteValues"][key];
                }
            }
            this.attributeRouteInfo = data["AttributeRouteInfo"] ? AttributeRouteInfo.fromJS(data["AttributeRouteInfo"]) : <any>undefined;
            if (data["ActionConstraints"] && data["ActionConstraints"].constructor === Array) {
                this.actionConstraints = [] as any;
                for (let item of data["ActionConstraints"])
                    this.actionConstraints!.push(IActionConstraintMetadata.fromJS(item));
            }
            if (data["EndpointMetadata"] && data["EndpointMetadata"].constructor === Array) {
                this.endpointMetadata = [] as any;
                for (let item of data["EndpointMetadata"])
                    this.endpointMetadata!.push(item);
            }
            if (data["Parameters"] && data["Parameters"].constructor === Array) {
                this.parameters = [] as any;
                for (let item of data["Parameters"])
                    this.parameters!.push(ParameterDescriptor.fromJS(item));
            }
            if (data["BoundProperties"] && data["BoundProperties"].constructor === Array) {
                this.boundProperties = [] as any;
                for (let item of data["BoundProperties"])
                    this.boundProperties!.push(ParameterDescriptor.fromJS(item));
            }
            if (data["FilterDescriptors"] && data["FilterDescriptors"].constructor === Array) {
                this.filterDescriptors = [] as any;
                for (let item of data["FilterDescriptors"])
                    this.filterDescriptors!.push(FilterDescriptor.fromJS(item));
            }
            this.displayName = data["DisplayName"];
            if (data["Properties"]) {
                this.properties = {} as any;
                for (let key in data["Properties"]) {
                    if (data["Properties"].hasOwnProperty(key))
                        this.properties![key] = data["Properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ActionDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ActionDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        if (this.routeValues) {
            data["RouteValues"] = {};
            for (let key in this.routeValues) {
                if (this.routeValues.hasOwnProperty(key))
                    data["RouteValues"][key] = this.routeValues[key];
            }
        }
        data["AttributeRouteInfo"] = this.attributeRouteInfo ? this.attributeRouteInfo.toJSON() : <any>undefined;
        if (this.actionConstraints && this.actionConstraints.constructor === Array) {
            data["ActionConstraints"] = [];
            for (let item of this.actionConstraints)
                data["ActionConstraints"].push(item.toJSON());
        }
        if (this.endpointMetadata && this.endpointMetadata.constructor === Array) {
            data["EndpointMetadata"] = [];
            for (let item of this.endpointMetadata)
                data["EndpointMetadata"].push(item);
        }
        if (this.parameters && this.parameters.constructor === Array) {
            data["Parameters"] = [];
            for (let item of this.parameters)
                data["Parameters"].push(item.toJSON());
        }
        if (this.boundProperties && this.boundProperties.constructor === Array) {
            data["BoundProperties"] = [];
            for (let item of this.boundProperties)
                data["BoundProperties"].push(item.toJSON());
        }
        if (this.filterDescriptors && this.filterDescriptors.constructor === Array) {
            data["FilterDescriptors"] = [];
            for (let item of this.filterDescriptors)
                data["FilterDescriptors"].push(item.toJSON());
        }
        data["DisplayName"] = this.displayName;
        if (this.properties) {
            data["Properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["Properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface IActionDescriptor {
    id?: string | undefined;
    routeValues?: { [key: string] : string; } | undefined;
    attributeRouteInfo?: AttributeRouteInfo | undefined;
    actionConstraints?: IActionConstraintMetadata[] | undefined;
    endpointMetadata?: any[] | undefined;
    parameters?: ParameterDescriptor[] | undefined;
    boundProperties?: ParameterDescriptor[] | undefined;
    filterDescriptors?: FilterDescriptor[] | undefined;
    displayName?: string | undefined;
    properties?: { [key: string] : any; } | undefined;
}

export class ControllerActionDescriptor extends ActionDescriptor implements IControllerActionDescriptor {
    controllerName?: string | undefined;
    actionName?: string | undefined;
    methodInfo?: MethodInfo | undefined;
    controllerTypeInfo?: string | undefined;
    displayName?: string | undefined;

    constructor(data?: IControllerActionDescriptor) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.controllerName = data["ControllerName"];
            this.actionName = data["ActionName"];
            this.methodInfo = data["MethodInfo"] ? MethodInfo.fromJS(data["MethodInfo"]) : <any>undefined;
            this.controllerTypeInfo = data["ControllerTypeInfo"];
            this.displayName = data["DisplayName"];
        }
    }

    static fromJS(data: any): ControllerActionDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ControllerActionDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ControllerName"] = this.controllerName;
        data["ActionName"] = this.actionName;
        data["MethodInfo"] = this.methodInfo ? this.methodInfo.toJSON() : <any>undefined;
        data["ControllerTypeInfo"] = this.controllerTypeInfo;
        data["DisplayName"] = this.displayName;
        super.toJSON(data);
        return data; 
    }
}

export interface IControllerActionDescriptor extends IActionDescriptor {
    controllerName?: string | undefined;
    actionName?: string | undefined;
    methodInfo?: MethodInfo | undefined;
    controllerTypeInfo?: string | undefined;
    displayName?: string | undefined;
}

export abstract class MemberInfo implements IMemberInfo {
    module?: Module | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;

    constructor(data?: IMemberInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.module = data["Module"] ? Module.fromJS(data["Module"]) : <any>undefined;
            if (data["CustomAttributes"] && data["CustomAttributes"].constructor === Array) {
                this.customAttributes = [] as any;
                for (let item of data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.metadataToken = data["MetadataToken"];
        }
    }

    static fromJS(data: any): MemberInfo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MemberInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Module"] = this.module ? this.module.toJSON() : <any>undefined;
        if (this.customAttributes && this.customAttributes.constructor === Array) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IMemberInfo {
    module?: Module | undefined;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export abstract class MethodBase extends MemberInfo implements IMethodBase {
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;

    constructor(data?: IMethodBase) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.methodImplementationFlags = data["MethodImplementationFlags"];
            this.callingConvention = data["CallingConvention"];
            this.isAbstract = data["IsAbstract"];
            this.isConstructor = data["IsConstructor"];
            this.isFinal = data["IsFinal"];
            this.isHideBySig = data["IsHideBySig"];
            this.isSpecialName = data["IsSpecialName"];
            this.isStatic = data["IsStatic"];
            this.isVirtual = data["IsVirtual"];
            this.isAssembly = data["IsAssembly"];
            this.isFamily = data["IsFamily"];
            this.isFamilyAndAssembly = data["IsFamilyAndAssembly"];
            this.isFamilyOrAssembly = data["IsFamilyOrAssembly"];
            this.isPrivate = data["IsPrivate"];
            this.isPublic = data["IsPublic"];
            this.isConstructedGenericMethod = data["IsConstructedGenericMethod"];
            this.isGenericMethod = data["IsGenericMethod"];
            this.isGenericMethodDefinition = data["IsGenericMethodDefinition"];
            this.containsGenericParameters = data["ContainsGenericParameters"];
            this.isSecurityCritical = data["IsSecurityCritical"];
            this.isSecuritySafeCritical = data["IsSecuritySafeCritical"];
            this.isSecurityTransparent = data["IsSecurityTransparent"];
        }
    }

    static fromJS(data: any): MethodBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MethodBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MethodImplementationFlags"] = this.methodImplementationFlags;
        data["CallingConvention"] = this.callingConvention;
        data["IsAbstract"] = this.isAbstract;
        data["IsConstructor"] = this.isConstructor;
        data["IsFinal"] = this.isFinal;
        data["IsHideBySig"] = this.isHideBySig;
        data["IsSpecialName"] = this.isSpecialName;
        data["IsStatic"] = this.isStatic;
        data["IsVirtual"] = this.isVirtual;
        data["IsAssembly"] = this.isAssembly;
        data["IsFamily"] = this.isFamily;
        data["IsFamilyAndAssembly"] = this.isFamilyAndAssembly;
        data["IsFamilyOrAssembly"] = this.isFamilyOrAssembly;
        data["IsPrivate"] = this.isPrivate;
        data["IsPublic"] = this.isPublic;
        data["IsConstructedGenericMethod"] = this.isConstructedGenericMethod;
        data["IsGenericMethod"] = this.isGenericMethod;
        data["IsGenericMethodDefinition"] = this.isGenericMethodDefinition;
        data["ContainsGenericParameters"] = this.containsGenericParameters;
        data["IsSecurityCritical"] = this.isSecurityCritical;
        data["IsSecuritySafeCritical"] = this.isSecuritySafeCritical;
        data["IsSecurityTransparent"] = this.isSecurityTransparent;
        super.toJSON(data);
        return data; 
    }
}

export interface IMethodBase extends IMemberInfo {
    methodImplementationFlags?: MethodImplAttributes;
    callingConvention?: CallingConventions;
    isAbstract?: boolean;
    isConstructor?: boolean;
    isFinal?: boolean;
    isHideBySig?: boolean;
    isSpecialName?: boolean;
    isStatic?: boolean;
    isVirtual?: boolean;
    isAssembly?: boolean;
    isFamily?: boolean;
    isFamilyAndAssembly?: boolean;
    isFamilyOrAssembly?: boolean;
    isPrivate?: boolean;
    isPublic?: boolean;
    isConstructedGenericMethod?: boolean;
    isGenericMethod?: boolean;
    isGenericMethodDefinition?: boolean;
    containsGenericParameters?: boolean;
    isSecurityCritical?: boolean;
    isSecuritySafeCritical?: boolean;
    isSecurityTransparent?: boolean;
}

export abstract class MethodInfo extends MethodBase implements IMethodInfo {
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo | undefined;
    returnType?: string | undefined;

    constructor(data?: IMethodInfo) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.memberType = data["MemberType"];
            this.returnParameter = data["ReturnParameter"] ? ParameterInfo.fromJS(data["ReturnParameter"]) : <any>undefined;
            this.returnType = data["ReturnType"];
        }
    }

    static fromJS(data: any): MethodInfo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MethodInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        data["ReturnParameter"] = this.returnParameter ? this.returnParameter.toJSON() : <any>undefined;
        data["ReturnType"] = this.returnType;
        super.toJSON(data);
        return data; 
    }
}

export interface IMethodInfo extends IMethodBase {
    memberType?: MemberTypes;
    returnParameter?: ParameterInfo | undefined;
    returnType?: string | undefined;
}

export enum MemberTypes {
    Constructor = 1, 
    Event = 2, 
    Field = 4, 
    Method = 8, 
    Property = 16, 
    TypeInfo = 32, 
    Custom = 64, 
    NestedType = 128, 
    All = 191, 
}

export class ParameterInfo implements IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo | undefined;
    name?: string | undefined;
    parameterType?: string | undefined;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;

    constructor(data?: IParameterInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attributes = data["Attributes"];
            this.member = data["Member"] ? MemberInfo.fromJS(data["Member"]) : <any>undefined;
            this.name = data["Name"];
            this.parameterType = data["ParameterType"];
            this.position = data["Position"];
            this.isIn = data["IsIn"];
            this.isLcid = data["IsLcid"];
            this.isOptional = data["IsOptional"];
            this.isOut = data["IsOut"];
            this.isRetval = data["IsRetval"];
            this.defaultValue = data["DefaultValue"];
            this.rawDefaultValue = data["RawDefaultValue"];
            this.hasDefaultValue = data["HasDefaultValue"];
            if (data["CustomAttributes"] && data["CustomAttributes"].constructor === Array) {
                this.customAttributes = [] as any;
                for (let item of data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.metadataToken = data["MetadataToken"];
        }
    }

    static fromJS(data: any): ParameterInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Attributes"] = this.attributes;
        data["Member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["Name"] = this.name;
        data["ParameterType"] = this.parameterType;
        data["Position"] = this.position;
        data["IsIn"] = this.isIn;
        data["IsLcid"] = this.isLcid;
        data["IsOptional"] = this.isOptional;
        data["IsOut"] = this.isOut;
        data["IsRetval"] = this.isRetval;
        data["DefaultValue"] = this.defaultValue;
        data["RawDefaultValue"] = this.rawDefaultValue;
        data["HasDefaultValue"] = this.hasDefaultValue;
        if (this.customAttributes && this.customAttributes.constructor === Array) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IParameterInfo {
    attributes?: ParameterAttributes;
    member?: MemberInfo | undefined;
    name?: string | undefined;
    parameterType?: string | undefined;
    position?: number;
    isIn?: boolean;
    isLcid?: boolean;
    isOptional?: boolean;
    isOut?: boolean;
    isRetval?: boolean;
    defaultValue?: any | undefined;
    rawDefaultValue?: any | undefined;
    hasDefaultValue?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export enum ParameterAttributes {
    None = 0, 
    In = 1, 
    Out = 2, 
    Lcid = 4, 
    Retval = 8, 
    Optional = 16, 
    HasDefault = 4096, 
    HasFieldMarshal = 8192, 
    Reserved3 = 16384, 
    Reserved4 = 32768, 
    ReservedMask = 61440, 
}

export abstract class Module implements IModule {
    assembly?: Assembly | undefined;
    fullyQualifiedName?: string | undefined;
    name?: string | undefined;
    mDStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;

    constructor(data?: IModule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assembly = data["Assembly"] ? Assembly.fromJS(data["Assembly"]) : <any>undefined;
            this.fullyQualifiedName = data["FullyQualifiedName"];
            this.name = data["Name"];
            this.mDStreamVersion = data["MDStreamVersion"];
            this.moduleVersionId = data["ModuleVersionId"];
            this.scopeName = data["ScopeName"];
            this.moduleHandle = data["ModuleHandle"] ? ModuleHandle.fromJS(data["ModuleHandle"]) : <any>undefined;
            if (data["CustomAttributes"] && data["CustomAttributes"].constructor === Array) {
                this.customAttributes = [] as any;
                for (let item of data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.metadataToken = data["MetadataToken"];
        }
    }

    static fromJS(data: any): Module {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Module' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Assembly"] = this.assembly ? this.assembly.toJSON() : <any>undefined;
        data["FullyQualifiedName"] = this.fullyQualifiedName;
        data["Name"] = this.name;
        data["MDStreamVersion"] = this.mDStreamVersion;
        data["ModuleVersionId"] = this.moduleVersionId;
        data["ScopeName"] = this.scopeName;
        data["ModuleHandle"] = this.moduleHandle ? this.moduleHandle.toJSON() : <any>undefined;
        if (this.customAttributes && this.customAttributes.constructor === Array) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["MetadataToken"] = this.metadataToken;
        return data; 
    }
}

export interface IModule {
    assembly?: Assembly | undefined;
    fullyQualifiedName?: string | undefined;
    name?: string | undefined;
    mDStreamVersion?: number;
    moduleVersionId?: string;
    scopeName?: string | undefined;
    moduleHandle?: ModuleHandle;
    customAttributes?: CustomAttributeData[] | undefined;
    metadataToken?: number;
}

export abstract class Assembly implements IAssembly {
    definedTypes?: string[] | undefined;
    exportedTypes?: string[] | undefined;
    codeBase?: string | undefined;
    entryPoint?: MethodInfo | undefined;
    fullName?: string | undefined;
    imageRuntimeVersion?: string | undefined;
    isDynamic?: boolean;
    location?: string | undefined;
    reflectionOnly?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    escapedCodeBase?: string | undefined;
    manifestModule?: Module | undefined;
    modules?: Module[] | undefined;
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: SecurityRuleSet;

    constructor(data?: IAssembly) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["DefinedTypes"] && data["DefinedTypes"].constructor === Array) {
                this.definedTypes = [] as any;
                for (let item of data["DefinedTypes"])
                    this.definedTypes!.push(item);
            }
            if (data["ExportedTypes"] && data["ExportedTypes"].constructor === Array) {
                this.exportedTypes = [] as any;
                for (let item of data["ExportedTypes"])
                    this.exportedTypes!.push(item);
            }
            this.codeBase = data["CodeBase"];
            this.entryPoint = data["EntryPoint"] ? MethodInfo.fromJS(data["EntryPoint"]) : <any>undefined;
            this.fullName = data["FullName"];
            this.imageRuntimeVersion = data["ImageRuntimeVersion"];
            this.isDynamic = data["IsDynamic"];
            this.location = data["Location"];
            this.reflectionOnly = data["ReflectionOnly"];
            this.isFullyTrusted = data["IsFullyTrusted"];
            if (data["CustomAttributes"] && data["CustomAttributes"].constructor === Array) {
                this.customAttributes = [] as any;
                for (let item of data["CustomAttributes"])
                    this.customAttributes!.push(CustomAttributeData.fromJS(item));
            }
            this.escapedCodeBase = data["EscapedCodeBase"];
            this.manifestModule = data["ManifestModule"] ? Module.fromJS(data["ManifestModule"]) : <any>undefined;
            if (data["Modules"] && data["Modules"].constructor === Array) {
                this.modules = [] as any;
                for (let item of data["Modules"])
                    this.modules!.push(Module.fromJS(item));
            }
            this.globalAssemblyCache = data["GlobalAssemblyCache"];
            this.hostContext = data["HostContext"];
            this.securityRuleSet = data["SecurityRuleSet"];
        }
    }

    static fromJS(data: any): Assembly {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Assembly' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.definedTypes && this.definedTypes.constructor === Array) {
            data["DefinedTypes"] = [];
            for (let item of this.definedTypes)
                data["DefinedTypes"].push(item);
        }
        if (this.exportedTypes && this.exportedTypes.constructor === Array) {
            data["ExportedTypes"] = [];
            for (let item of this.exportedTypes)
                data["ExportedTypes"].push(item);
        }
        data["CodeBase"] = this.codeBase;
        data["EntryPoint"] = this.entryPoint ? this.entryPoint.toJSON() : <any>undefined;
        data["FullName"] = this.fullName;
        data["ImageRuntimeVersion"] = this.imageRuntimeVersion;
        data["IsDynamic"] = this.isDynamic;
        data["Location"] = this.location;
        data["ReflectionOnly"] = this.reflectionOnly;
        data["IsFullyTrusted"] = this.isFullyTrusted;
        if (this.customAttributes && this.customAttributes.constructor === Array) {
            data["CustomAttributes"] = [];
            for (let item of this.customAttributes)
                data["CustomAttributes"].push(item.toJSON());
        }
        data["EscapedCodeBase"] = this.escapedCodeBase;
        data["ManifestModule"] = this.manifestModule ? this.manifestModule.toJSON() : <any>undefined;
        if (this.modules && this.modules.constructor === Array) {
            data["Modules"] = [];
            for (let item of this.modules)
                data["Modules"].push(item.toJSON());
        }
        data["GlobalAssemblyCache"] = this.globalAssemblyCache;
        data["HostContext"] = this.hostContext;
        data["SecurityRuleSet"] = this.securityRuleSet;
        return data; 
    }
}

export interface IAssembly {
    definedTypes?: string[] | undefined;
    exportedTypes?: string[] | undefined;
    codeBase?: string | undefined;
    entryPoint?: MethodInfo | undefined;
    fullName?: string | undefined;
    imageRuntimeVersion?: string | undefined;
    isDynamic?: boolean;
    location?: string | undefined;
    reflectionOnly?: boolean;
    isFullyTrusted?: boolean;
    customAttributes?: CustomAttributeData[] | undefined;
    escapedCodeBase?: string | undefined;
    manifestModule?: Module | undefined;
    modules?: Module[] | undefined;
    globalAssemblyCache?: boolean;
    hostContext?: number;
    securityRuleSet?: SecurityRuleSet;
}

export class CustomAttributeData implements ICustomAttributeData {
    attributeType?: string | undefined;
    constructor_?: ConstructorInfo | undefined;
    constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    namedArguments?: CustomAttributeNamedArgument[] | undefined;

    constructor(data?: ICustomAttributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attributeType = data["AttributeType"];
            this.constructor_ = data["Constructor"] ? ConstructorInfo.fromJS(data["Constructor"]) : <any>undefined;
            if (data["ConstructorArguments"] && data["ConstructorArguments"].constructor === Array) {
                this.constructorArguments = [] as any;
                for (let item of data["ConstructorArguments"])
                    this.constructorArguments!.push(CustomAttributeTypedArgument.fromJS(item));
            }
            if (data["NamedArguments"] && data["NamedArguments"].constructor === Array) {
                this.namedArguments = [] as any;
                for (let item of data["NamedArguments"])
                    this.namedArguments!.push(CustomAttributeNamedArgument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomAttributeData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AttributeType"] = this.attributeType;
        data["Constructor"] = this.constructor_ ? this.constructor_.toJSON() : <any>undefined;
        if (this.constructorArguments && this.constructorArguments.constructor === Array) {
            data["ConstructorArguments"] = [];
            for (let item of this.constructorArguments)
                data["ConstructorArguments"].push(item.toJSON());
        }
        if (this.namedArguments && this.namedArguments.constructor === Array) {
            data["NamedArguments"] = [];
            for (let item of this.namedArguments)
                data["NamedArguments"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomAttributeData {
    attributeType?: string | undefined;
    constructor_?: ConstructorInfo | undefined;
    constructorArguments?: CustomAttributeTypedArgument[] | undefined;
    namedArguments?: CustomAttributeNamedArgument[] | undefined;
}

export abstract class ConstructorInfo extends MethodBase implements IConstructorInfo {
    memberType?: MemberTypes;

    constructor(data?: IConstructorInfo) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.memberType = data["MemberType"];
        }
    }

    static fromJS(data: any): ConstructorInfo {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ConstructorInfo' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberType"] = this.memberType;
        super.toJSON(data);
        return data; 
    }
}

export interface IConstructorInfo extends IMethodBase {
    memberType?: MemberTypes;
}

export enum MethodImplAttributes {
    Managed = 0, 
    IL = 0, 
    Native = 1, 
    OPTIL = 2, 
    Runtime = 3, 
    CodeTypeMask = 3, 
    Unmanaged = 4, 
    ManagedMask = 4, 
    NoInlining = 8, 
    ForwardRef = 16, 
    Synchronized = 32, 
    NoOptimization = 64, 
    PreserveSig = 128, 
    AggressiveInlining = 256, 
    InternalCall = 4096, 
    MaxMethodImplVal = 65535, 
}

export enum CallingConventions {
    Standard = 1, 
    VarArgs = 2, 
    Any = 3, 
    HasThis = 32, 
    ExplicitThis = 64, 
}

export class CustomAttributeTypedArgument implements ICustomAttributeTypedArgument {
    argumentType?: string | undefined;
    value?: any | undefined;

    constructor(data?: ICustomAttributeTypedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.argumentType = data["ArgumentType"];
            this.value = data["Value"];
        }
    }

    static fromJS(data: any): CustomAttributeTypedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeTypedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ArgumentType"] = this.argumentType;
        data["Value"] = this.value;
        return data; 
    }
}

export interface ICustomAttributeTypedArgument {
    argumentType?: string | undefined;
    value?: any | undefined;
}

export class CustomAttributeNamedArgument implements ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo | undefined;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string | undefined;
    isField?: boolean;

    constructor(data?: ICustomAttributeNamedArgument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberInfo = data["MemberInfo"] ? MemberInfo.fromJS(data["MemberInfo"]) : <any>undefined;
            this.typedValue = data["TypedValue"] ? CustomAttributeTypedArgument.fromJS(data["TypedValue"]) : <any>undefined;
            this.memberName = data["MemberName"];
            this.isField = data["IsField"];
        }
    }

    static fromJS(data: any): CustomAttributeNamedArgument {
        data = typeof data === 'object' ? data : {};
        let result = new CustomAttributeNamedArgument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MemberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        data["TypedValue"] = this.typedValue ? this.typedValue.toJSON() : <any>undefined;
        data["MemberName"] = this.memberName;
        data["IsField"] = this.isField;
        return data; 
    }
}

export interface ICustomAttributeNamedArgument {
    memberInfo?: MemberInfo | undefined;
    typedValue?: CustomAttributeTypedArgument;
    memberName?: string | undefined;
    isField?: boolean;
}

export enum SecurityRuleSet {
    None = 0, 
    Level1 = 1, 
    Level2 = 2, 
}

export class ModuleHandle implements IModuleHandle {
    mDStreamVersion?: number;

    constructor(data?: IModuleHandle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mDStreamVersion = data["MDStreamVersion"];
        }
    }

    static fromJS(data: any): ModuleHandle {
        data = typeof data === 'object' ? data : {};
        let result = new ModuleHandle();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["MDStreamVersion"] = this.mDStreamVersion;
        return data; 
    }
}

export interface IModuleHandle {
    mDStreamVersion?: number;
}

export class AttributeRouteInfo implements IAttributeRouteInfo {
    template?: string | undefined;
    order?: number;
    name?: string | undefined;
    suppressLinkGeneration?: boolean;
    suppressPathMatching?: boolean;

    constructor(data?: IAttributeRouteInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.template = data["Template"];
            this.order = data["Order"];
            this.name = data["Name"];
            this.suppressLinkGeneration = data["SuppressLinkGeneration"];
            this.suppressPathMatching = data["SuppressPathMatching"];
        }
    }

    static fromJS(data: any): AttributeRouteInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AttributeRouteInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Template"] = this.template;
        data["Order"] = this.order;
        data["Name"] = this.name;
        data["SuppressLinkGeneration"] = this.suppressLinkGeneration;
        data["SuppressPathMatching"] = this.suppressPathMatching;
        return data; 
    }
}

export interface IAttributeRouteInfo {
    template?: string | undefined;
    order?: number;
    name?: string | undefined;
    suppressLinkGeneration?: boolean;
    suppressPathMatching?: boolean;
}

export abstract class IActionConstraintMetadata implements IIActionConstraintMetadata {

    constructor(data?: IIActionConstraintMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IActionConstraintMetadata {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IActionConstraintMetadata' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIActionConstraintMetadata {
}

export class ParameterDescriptor implements IParameterDescriptor {
    name?: string | undefined;
    parameterType?: string | undefined;
    bindingInfo?: BindingInfo | undefined;

    constructor(data?: IParameterDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["Name"];
            this.parameterType = data["ParameterType"];
            this.bindingInfo = data["BindingInfo"] ? BindingInfo.fromJS(data["BindingInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ParameterDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["ParameterType"] = this.parameterType;
        data["BindingInfo"] = this.bindingInfo ? this.bindingInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IParameterDescriptor {
    name?: string | undefined;
    parameterType?: string | undefined;
    bindingInfo?: BindingInfo | undefined;
}

export class BindingInfo implements IBindingInfo {
    bindingSource?: BindingSource | undefined;
    binderModelName?: string | undefined;
    binderType?: string | undefined;
    propertyFilterProvider?: IPropertyFilterProvider | undefined;
    requestPredicate?: FuncOfActionContextAndBoolean | undefined;

    constructor(data?: IBindingInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.bindingSource = data["BindingSource"] ? BindingSource.fromJS(data["BindingSource"]) : <any>undefined;
            this.binderModelName = data["BinderModelName"];
            this.binderType = data["BinderType"];
            this.propertyFilterProvider = data["PropertyFilterProvider"] ? IPropertyFilterProvider.fromJS(data["PropertyFilterProvider"]) : <any>undefined;
            this.requestPredicate = data["RequestPredicate"] ? FuncOfActionContextAndBoolean.fromJS(data["RequestPredicate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BindingInfo {
        data = typeof data === 'object' ? data : {};
        let result = new BindingInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["BindingSource"] = this.bindingSource ? this.bindingSource.toJSON() : <any>undefined;
        data["BinderModelName"] = this.binderModelName;
        data["BinderType"] = this.binderType;
        data["PropertyFilterProvider"] = this.propertyFilterProvider ? this.propertyFilterProvider.toJSON() : <any>undefined;
        data["RequestPredicate"] = this.requestPredicate ? this.requestPredicate.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBindingInfo {
    bindingSource?: BindingSource | undefined;
    binderModelName?: string | undefined;
    binderType?: string | undefined;
    propertyFilterProvider?: IPropertyFilterProvider | undefined;
    requestPredicate?: FuncOfActionContextAndBoolean | undefined;
}

export class BindingSource implements IBindingSource {
    displayName?: string | undefined;
    id?: string | undefined;
    isGreedy?: boolean;
    isFromRequest?: boolean;

    constructor(data?: IBindingSource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["DisplayName"];
            this.id = data["Id"];
            this.isGreedy = data["IsGreedy"];
            this.isFromRequest = data["IsFromRequest"];
        }
    }

    static fromJS(data: any): BindingSource {
        data = typeof data === 'object' ? data : {};
        let result = new BindingSource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DisplayName"] = this.displayName;
        data["Id"] = this.id;
        data["IsGreedy"] = this.isGreedy;
        data["IsFromRequest"] = this.isFromRequest;
        return data; 
    }
}

export interface IBindingSource {
    displayName?: string | undefined;
    id?: string | undefined;
    isGreedy?: boolean;
    isFromRequest?: boolean;
}

export abstract class IPropertyFilterProvider implements IIPropertyFilterProvider {
    propertyFilter?: FuncOfModelMetadataAndBoolean | undefined;

    constructor(data?: IIPropertyFilterProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyFilter = data["PropertyFilter"] ? FuncOfModelMetadataAndBoolean.fromJS(data["PropertyFilter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IPropertyFilterProvider {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IPropertyFilterProvider' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PropertyFilter"] = this.propertyFilter ? this.propertyFilter.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIPropertyFilterProvider {
    propertyFilter?: FuncOfModelMetadataAndBoolean | undefined;
}

export abstract class Delegate implements IDelegate {
    method?: MethodInfo | undefined;
    target?: any | undefined;

    constructor(data?: IDelegate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.method = data["Method"] ? MethodInfo.fromJS(data["Method"]) : <any>undefined;
            this.target = data["Target"];
        }
    }

    static fromJS(data: any): Delegate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Delegate' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Method"] = this.method ? this.method.toJSON() : <any>undefined;
        data["Target"] = this.target;
        return data; 
    }
}

export interface IDelegate {
    method?: MethodInfo | undefined;
    target?: any | undefined;
}

export abstract class MulticastDelegate extends Delegate implements IMulticastDelegate {

    constructor(data?: IMulticastDelegate) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): MulticastDelegate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'MulticastDelegate' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IMulticastDelegate extends IDelegate {
}

export class FuncOfModelMetadataAndBoolean extends MulticastDelegate implements IFuncOfModelMetadataAndBoolean {

    constructor(data?: IFuncOfModelMetadataAndBoolean) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): FuncOfModelMetadataAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new FuncOfModelMetadataAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFuncOfModelMetadataAndBoolean extends IMulticastDelegate {
}

export class FuncOfActionContextAndBoolean extends MulticastDelegate implements IFuncOfActionContextAndBoolean {

    constructor(data?: IFuncOfActionContextAndBoolean) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): FuncOfActionContextAndBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new FuncOfActionContextAndBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IFuncOfActionContextAndBoolean extends IMulticastDelegate {
}

export class FilterDescriptor implements IFilterDescriptor {
    filter?: IFilterMetadata | undefined;
    order?: number;
    scope?: number;

    constructor(data?: IFilterDescriptor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filter = data["Filter"] ? IFilterMetadata.fromJS(data["Filter"]) : <any>undefined;
            this.order = data["Order"];
            this.scope = data["Scope"];
        }
    }

    static fromJS(data: any): FilterDescriptor {
        data = typeof data === 'object' ? data : {};
        let result = new FilterDescriptor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Filter"] = this.filter ? this.filter.toJSON() : <any>undefined;
        data["Order"] = this.order;
        data["Scope"] = this.scope;
        return data; 
    }
}

export interface IFilterDescriptor {
    filter?: IFilterMetadata | undefined;
    order?: number;
    scope?: number;
}

export abstract class IFilterMetadata implements IIFilterMetadata {

    constructor(data?: IIFilterMetadata) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IFilterMetadata {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IFilterMetadata' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIFilterMetadata {
}

export abstract class IValueProviderFactory implements IIValueProviderFactory {

    constructor(data?: IIValueProviderFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IValueProviderFactory {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IValueProviderFactory' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIValueProviderFactory {
}

export abstract class IModelMetadataProvider implements IIModelMetadataProvider {

    constructor(data?: IIModelMetadataProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IModelMetadataProvider {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IModelMetadataProvider' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIModelMetadataProvider {
}

export abstract class IModelBinderFactory implements IIModelBinderFactory {

    constructor(data?: IIModelBinderFactory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IModelBinderFactory {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IModelBinderFactory' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIModelBinderFactory {
}

export abstract class IUrlHelper implements IIUrlHelper {
    actionContext?: ActionContext | undefined;

    constructor(data?: IIUrlHelper) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionContext = data["ActionContext"] ? ActionContext.fromJS(data["ActionContext"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IUrlHelper {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IUrlHelper' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ActionContext"] = this.actionContext ? this.actionContext.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIUrlHelper {
    actionContext?: ActionContext | undefined;
}

export abstract class IObjectModelValidator implements IIObjectModelValidator {

    constructor(data?: IIObjectModelValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): IObjectModelValidator {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IObjectModelValidator' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IIObjectModelValidator {
}

export class ClaimsPrincipal implements IClaimsPrincipal {
    claims?: Claim[] | undefined;
    identities?: ClaimsIdentity[] | undefined;
    identity?: IIdentity | undefined;

    constructor(data?: IClaimsPrincipal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Claims"] && data["Claims"].constructor === Array) {
                this.claims = [] as any;
                for (let item of data["Claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            if (data["Identities"] && data["Identities"].constructor === Array) {
                this.identities = [] as any;
                for (let item of data["Identities"])
                    this.identities!.push(ClaimsIdentity.fromJS(item));
            }
            this.identity = data["Identity"] ? IIdentity.fromJS(data["Identity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ClaimsPrincipal {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsPrincipal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.claims && this.claims.constructor === Array) {
            data["Claims"] = [];
            for (let item of this.claims)
                data["Claims"].push(item.toJSON());
        }
        if (this.identities && this.identities.constructor === Array) {
            data["Identities"] = [];
            for (let item of this.identities)
                data["Identities"].push(item.toJSON());
        }
        data["Identity"] = this.identity ? this.identity.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IClaimsPrincipal {
    claims?: Claim[] | undefined;
    identities?: ClaimsIdentity[] | undefined;
    identity?: IIdentity | undefined;
}

export class Claim implements IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    properties?: { [key: string] : string; } | undefined;
    subject?: ClaimsIdentity | undefined;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.issuer = data["Issuer"];
            this.originalIssuer = data["OriginalIssuer"];
            if (data["Properties"]) {
                this.properties = {} as any;
                for (let key in data["Properties"]) {
                    if (data["Properties"].hasOwnProperty(key))
                        this.properties![key] = data["Properties"][key];
                }
            }
            this.subject = data["Subject"] ? ClaimsIdentity.fromJS(data["Subject"]) : <any>undefined;
            this.type = data["Type"];
            this.value = data["Value"];
            this.valueType = data["ValueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Issuer"] = this.issuer;
        data["OriginalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["Properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["Properties"][key] = this.properties[key];
            }
        }
        data["Subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["Type"] = this.type;
        data["Value"] = this.value;
        data["ValueType"] = this.valueType;
        return data; 
    }
}

export interface IClaim {
    issuer?: string | undefined;
    originalIssuer?: string | undefined;
    properties?: { [key: string] : string; } | undefined;
    subject?: ClaimsIdentity | undefined;
    type?: string | undefined;
    value?: string | undefined;
    valueType?: string | undefined;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string | undefined;
    roleClaimType?: string | undefined;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authenticationType = data["AuthenticationType"];
            this.isAuthenticated = data["IsAuthenticated"];
            this.actor = data["Actor"] ? ClaimsIdentity.fromJS(data["Actor"]) : <any>undefined;
            this.bootstrapContext = data["BootstrapContext"];
            if (data["Claims"] && data["Claims"].constructor === Array) {
                this.claims = [] as any;
                for (let item of data["Claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.label = data["Label"];
            this.name = data["Name"];
            this.nameClaimType = data["NameClaimType"];
            this.roleClaimType = data["RoleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AuthenticationType"] = this.authenticationType;
        data["IsAuthenticated"] = this.isAuthenticated;
        data["Actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["BootstrapContext"] = this.bootstrapContext;
        if (this.claims && this.claims.constructor === Array) {
            data["Claims"] = [];
            for (let item of this.claims)
                data["Claims"].push(item.toJSON());
        }
        data["Label"] = this.label;
        data["Name"] = this.name;
        data["NameClaimType"] = this.nameClaimType;
        data["RoleClaimType"] = this.roleClaimType;
        return data; 
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[] | undefined;
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string | undefined;
    roleClaimType?: string | undefined;
}

export abstract class IIdentity implements IIIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    name?: string | undefined;

    constructor(data?: IIIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authenticationType = data["AuthenticationType"];
            this.isAuthenticated = data["IsAuthenticated"];
            this.name = data["Name"];
        }
    }

    static fromJS(data: any): IIdentity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IIdentity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AuthenticationType"] = this.authenticationType;
        data["IsAuthenticated"] = this.isAuthenticated;
        data["Name"] = this.name;
        return data; 
    }
}

export interface IIIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    name?: string | undefined;
}

export class CustomersController extends Controller implements ICustomersController {

    constructor(data?: ICustomersController) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): CustomersController {
        data = typeof data === 'object' ? data : {};
        let result = new CustomersController();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomersController extends IController {
}

export class IdentityController extends Controller implements IIdentityController {

    constructor(data?: IIdentityController) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): IdentityController {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityController();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IIdentityController extends IController {
}

export class InsuranceCasesController extends Controller implements IInsuranceCasesController {

    constructor(data?: IInsuranceCasesController) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): InsuranceCasesController {
        data = typeof data === 'object' ? data : {};
        let result = new InsuranceCasesController();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IInsuranceCasesController extends IController {
}

export class LookupController extends Controller implements ILookupController {

    constructor(data?: ILookupController) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): LookupController {
        data = typeof data === 'object' ? data : {};
        let result = new LookupController();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ILookupController extends IController {
}